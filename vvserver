#!/bin/bash

# Created by Nick "thakyZ" Mullally

# Do not edit this file!

selfName=$(basename "$(readlink -f "${BASH_SOURCE[0]}")")
rootName=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")

screenName="${shortName}server"
logFile="${shortName}server"

backupsPath="$HOME/backups"
logPath="$HOME/log"

serverPath="${rootName}/${screenName}files"
toExec="$HOME/$serverPath/$binPath/$executable"
runCommand="$toExec $arguments"

version="v0.0.1"

updateLogPath="$logPath/update"
scriptLogPath="$logPath/script"
consoleLogPath="$logPath/console"
serverLogPath="$logPath/server"

lockFile="/var/lock/$(basename $0)"
lockFD=99

debug=0

date=$(date "+%Y-%m-%d_%H.%M.%S")

source "./${screenName}.cfg"

if [ -f "$scriptLogPath/script.log" ]; then
  mv "$scriptLogPath/script.log" "$scriptLogPath/script_${date}.log"
  touch "$scriptLogPath/script.log"
fi

lib_check_running() {
  if [ "$(ps aux | grep "${processName}" | grep -v grep | grep -v tmux | grep -v sh | grep -v script | awk '{print $2}')" != "" ]; then
    if [ debug == 1 ]; then
      echo "[ DEBG ] RUNNING\n" > "$scriptLogPath/script.log"
    fi

    status=RUNNING
    return 0
  else
    if [ debug == 1 ]; then
      echo "[ DEBG ] STOPPED\n" > "$scriptLogPath/script.log"
    fi

    status=STOPPED
    return 1
  fi
}

lib_screenadd() {
  # usage lib_addscreen screen
  if ps aux | grep -v grep | grep SCREEN | grep "$1" >/dev/null; then
    echo "[WARN] Screen(s) identified by $1 detected and will be closed."
    PIDS=( $(ps aux | grep -v grep | grep SCREEN | grep "$1" | awk '{print $2}') )
    echo "[WARN] Trying to kill these ${PIDS[*]}."
    kill "${PIDS[@]}"
  fi
  echo "[INFP] Starting screen $1."
  screen -dmS "$1"
}

lib_screensend() {
 usage lib_screensend screen command
        STUFFCOMMAND="${*:2}"
        echo "trying to send this command $STUFFCOMMAND to the screen $1"
        screen -p 0 -S "$1" -X stuff "$STUFFCOMMAND""$(printf \\r)"
}

core_start() {
  echo "[INFO] Starting $programType."
  if lib_check_running; then
    echo "[WARN] Tried to start but $programName was already running!"
  else
    echo "[INFO] $programName was not running... starting."
    if [ -e "$runPath/$logFile.log" ]; then


      if [ ! -d "$runPath/dump" ]; then
        mkdir "$runPath/dump"
      fi

      currentdate=$(date +"%m-%d-%y_%T")
      cp "$runPath/$logFile.log" "$runPath/dump/${logFile}_${currentdate}.log"
    fi

# Lib_screenadd will detect if screens already running and will terminate them if so.
    #lib_screenadd "$screenName"
# For the bot to run correctly it must be launched from the correct directory
    #lib_screensend "$screenName" "cd \"$runPath\""
# Start script which will create a shell that is logged for all output. This is useful to see the commands that are given.
# -f is used to flush data as it is given and keeps the log file updated quickly.
    #lib_screensend "$screenName" "script -f \"$runPath/$logFile.log\""
# Start the bot.
    #lib_screensend "$screenName" "$runCMD"
    cd "${runPath}"
    tmux new-session -d -x 23 -y 80 -s ${screenName} "script \"${runPath}/${logFile}.log\" -c \"${runCMD}\""
  fi
}

core_status() {
# Quick test to see if bot appears to be running.  This will not detect a locked state for the bot.
  echo "Testing $programType status"
  if lib_check_running
  then
    echo "[INFO] $programType is running."
  else
    echo "[INFO] $programType is stopped."
  fi
}

core_monitor() {
  echo "[INFO] Monitoring the $programName."
  if lib_check_running
  then
    echo "[INFO] $programName is still running."
  else
    echo "[WARN] $programName was not running!"
    core_start
  fi
}

core_safestop() {
  echo -e "[ INFO ] Safe stoping the $programType"
  while lib_check_running; do
#    if [ $ran = 1 ]; then
#      echo "finished"
#    else
    if [ $ran = 0 ]; then
      tmux send -t "$screenName" exit ENTER
#      echo "ran once"
      ran=1
    fi
  done
}

lib_forcestop() {
  echo -e "[ INFO ] Closing $programType."
  tmux send-keys -t "$screenName" C-c
}

core_stop() {
  lib_forcestop
  core_kill
}

core_kill() {
# Kill server and all functions by closing their screens
  echo "[INFO] Killing $programType."
  PIDS=($(ps aux | grep "${processName}" | grep -v grep | grep -v tmux | grep -v sh | grep -v script | awk '{print $2}'))
  if [ -n "$PIDS" ]
  then
    echo "Trying to kill these ${PIDS[*]} for $programType."
    kill "${PIDS[@]}"
    for LOOPNO in {0..30}
      do
        if ps aux | grep -v grep | grep "$processName" | grep -v tmux | grep -v sh | grep -v script >/dev/null
        then
          sleep 1
        else
          echo "[INFO] $processName took $LOOPNO seconds to close."
          break
        fi
    done
  else
    echo "[WARN] It does not appear the $programType is running."
  fi
#  if ps aux | grep -v grep | grep SCREEN | grep "$screenName" >/dev/null
#  then
#    echo "[INFO] Screen(s) identified by $screenName detected and will be closed"
#    PIDS=($(ps aux | grep -v grep | grep SCREEN | grep $screenName | awk '{print $2}'))
#    echo "[INFO] Trying to kill these ${PIDS[*]}"
#    kill "${PIDS[@]}"
#  else
#    echo "[WARN] It does not appear the screen(s) for $programName is running."
#  fi
}

core_restart() {
  core_safestop
  sleep 10
  core_stop
  core_start
}

core_update() {
  echo "[INFO] Updating $programType/dependencies."
  echo "[INFO] Checking if $programType is running."
  if lib_check_running
  then
    echo "[INFO] $programName is running... Stopping to update."
    wasRunning=1
    core_stop
  else
    echo "[INFO] $programName is not running... Continuing."
    wasRunning=0
  fi

  echo "[INFO] Performing update."
  cd "$runPath"
  if [ $1 -eq 0 ]
  then
    echo "[INFO] Script update started..."
    eval "$updateCMD"
  elif [ $1 -eq 1 ]
  then
    echo "[INFO] Full update started..."
    eval "$updateFullCMD"
    eval "$updateCMD"
  fi
  echo "[INFO] Update finished!"

  echo "[INFO] Was the $programName running?"
  if [ $wasRunning -eq 1 ]
  then
    echo "[INFO] $programName was running. Starting..."
    core_start
  else
    echo "[INFO] $programName was not running..."
  fi

  echo "[INFO] Update finished!"
}

while true
do
  command="$1"

  case "$command" in
    st|start)
      core_start
      exit 0
    ;;
    sp|stop)
      core_safestop
      exit 0
    ;;
    k|kill)
      core_kill
      exit 0
    ;;
    fs|force-stop)
      core_stop
      exit 0
    ;;
    r|restart)
      core_restart
      exit 0
    ;;
    s|status)
      core_status
      exit 0
    ;;
    m|monitor)
      core_monitor
      exit 0
    ;;
    u|update)
      core_update 0
      exit 0
    ;;
    uf|updateFull)
      core_update 1
      exit 0
    ;;
    c|console)
      tmux attach -t "${screenName}"
      exit 0
    ;;
    -v|--version)
      echo "Universal Daemon Script $version"
      exit 0
    ;;
    -h|--help)
      echo "UDS usage: $(basename "$0") [ start stop kill restart status monitor update updateFull --version --help ]"
      exit 0
    ;;
    *)
      echo "UDS usage: $(basename "$0") [ start stop kill restart status monitor update updateFull --version --help ]"
      exit 0
    ;;
  esac

  laststatus=$?
  if [ $laststatus -eq 255 ]; then
    exit 1
  elif [ $laststatus -eq 0 ]; then
    status=$laststatus
    status=$status
  fi

  if [ $# -eq 0 ]; then
    exit
  fi
done

exit "$status"
